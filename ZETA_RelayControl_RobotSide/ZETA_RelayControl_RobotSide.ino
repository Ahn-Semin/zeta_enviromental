 /* 
  *       Author         Ahn semin
  *       Created        2020.05.07
  *       Last modified  2020.05.07 18:37
  *       Description    Relay switch control for Autonomous charging(Robot side Arduino Mega)
  */
#define CNT_PINP              2   // reads PWM signal which is generated by Nano(station)
#define CNT_PINN              3

#define PWM_threshold         100
#define WData_len             70
#define RData_len             50
#define SERIAL_SPEED          115200
#define BUFFER_SIZE           255
#define CHARGING_FINISH_TIME  7000UL   // ms
#define CALLBACK_PERIOD       5000      // ms

#include <ros.h>
#include <std_msgs/String.h>
#include <Timer.h>

// ROS variables
ros::NodeHandle   nh;
std_msgs::String  ContactPubMsg;
String            ContactSubMsg;

ros::Publisher    ContactPub("contact",&ContactPubMsg);

// ROS subscribe callback func.
void ContactSubCallback(const std_msgs::String& msg);

ros::Subscriber<std_msgs::String> ContactSub("contact_sub",&ContactSubCallback);

// 

Timer tTimer;
// 
uint32_t PWM_CNT_P       = 0;
uint32_t PWM_CNT_N       = 0;
bool ContactFlag_P       = false;
bool ContactFlag_N       = false;

// other variables
uint32_t TimeChargingStart    = 0;
bool ContactFlag              = false;
bool ChargingFinishFlag       = false;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(SERIAL_SPEED);
  attachInterrupt(digitalPinToInterrupt(CNT_PINP), ContactCallbackP, RISING);  // reads PWM which is generated from NANO(station)
  attachInterrupt(digitalPinToInterrupt(CNT_PINN), ContactCallbackN, RISING);
  delay(10);
  ContactSubMsg.reserve(BUFFER_SIZE);
  nh.getHardware()->setBaud(SERIAL_SPEED);
  nh.initNode();
  nh.advertise(ContactPub);
  nh.subscribe(ContactSub);
  delay(1000);
  nh.loginfo("ready to publish contact information");
  nh.loginfo("========================================");
  delay(1000);
  ROSPublishing("");
  delay(1000);
  tTimer.every(CALLBACK_PERIOD, Refresh);
}

void loop() {
  // put your main code here, to run repeatedly:
  uint32_t TimeChargingCurrent  = millis(); 
  if(ContactFlag_P && ContactFlag_N && !ContactFlag) ContactFlag = true;
  if(ContactFlag) {
    detachInterrupt(digitalPinToInterrupt(CNT_PINP));
    detachInterrupt(digitalPinToInterrupt(CNT_PINN));
    ROSPublishing("contact");
    TimeChargingStart = TimeChargingCurrent;
    ContactFlag_P = false;
    ContactFlag_N = false;
    ContactFlag   = false;
  }
  if(TimeChargingCurrent - TimeChargingStart > CHARGING_FINISH_TIME) ChargingFinishFlag = true;
  if(ChargingFinishFlag) {
    ChargingFinishFlag = false;
    if(TimeChargingStart > 1) ROSPublishing("Charging done.");
    TimeChargingStart = 0;
  }
  tTimer.update();
}



// Interrupt callback func.
void ContactCallbackP() {
  if(!ContactFlag_P) PWM_CNT_P++;
  if(PWM_CNT_P > PWM_threshold) ContactFlag_P = true;
}

void ContactCallbackN() {
  if(!ContactFlag_N) PWM_CNT_N++;
  if(PWM_CNT_N > PWM_threshold) ContactFlag_N = true;
}

// ROS publishing func.
void ROSPublishing(String sendmsg) {
  char buffer[BUFFER_SIZE] = {'\0',};
  sendmsg.toCharArray(buffer, sendmsg.length()+1);
  //nh.loginfo(buffer);
  ContactPubMsg.data = buffer;
  ContactPub.publish(&ContactPubMsg);
  nh.spinOnce();
}

// ROS subscribe callback func.
void ContactSubCallback(const std_msgs::String& msg) {
  ContactSubMsg = msg.data;
}

//
void Refresh() {
  ROSPublishing("");
}

// EOF
