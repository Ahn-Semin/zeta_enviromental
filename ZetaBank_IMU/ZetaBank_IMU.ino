// last modified 2020.05.06 19:06
//#include <IMU.h>
#include <MPU9250.h>


#define __DEBUG
#define _DEBUG

// Define commands

#define SEND_IMUDATA          0x10
#define SEND_IMUDATA_ONCE     0x11
#define SEND_IMUDATA_CONT     0x12
#define STOP_IMUDATA_CONT     0x13
#define SEND_IMUCALIGYRO      0x14

#define SEND_USDATA           0x20
#define SEND_USDATA_ONCE      0x21
#define SEND_USDATA_CONT      0x22
#define STOP_USDATA_CONT      0x23

#define LEFTFRONT_EN          22
#define LEFTFRONT_PW          23
#define RIGHTFRONT_EN         30
#define RIGHTFRONT_PW         31
#define LEFTREAR_EN           24
#define LEFTREAR_PW           25
#define RIGHTREAR_EN          32
#define RIGHTREAR_PW          33
#define REARLEFT_EN           26
#define REARLEFT_PW           27
#define REARCENTER_EN         34
#define REARCENTER_PW         35
#define REARRIGHT_EN          28
#define REARRIGHT_PW          29

#define LF                    0
#define RF                    1
#define LR                    2
#define RR                    3
#define R_L                   4
#define R_C                   5
#define R_R                   6

#define CNT_PIN               2   // reads PWM signal which is generated by Nano(station)
#define PWM_threshold         500
#define WData_len             70
#define RData_len             50

cMPU9250 SEN;


//cIMU imu_;

union INTVAL {
  char cval[4];
  int ival;
} int_val;

union UINTVAL {
  char cval[4];
  uint32_t uival;
} uint_val;

union SHORTVAL {
  char cval[2];
  short sval;
} short_val;

union WNTVAL {
  char cval[2];
  uint16_t wval;
} word_val;

union FLOATVAL {
  char cval[4];
  float fval;
} float_val;

byte startcnt     = 0;
byte b_StartFlag  = 0;
byte rsize        = 0;



char RData[RData_len] = {0,};
char WData[WData_len] = {0,};

//-------- IMU ---------------

bool bConnected;
const float G = -9.807f;
const float Deg2Rad = 3.14159265359f/180.0f;

float AccelFactor  = 0.0;
float GyroFactor   = 0.0;
float MagFactor[3] = {0.0,};

uint16_t IMULoopFreq        = 50;    // Hz
unsigned long IMUStartTime  = 0;
unsigned long IMUEndTime    = 0;
unsigned long IMULoopTime   = 0;

bool b_IMUSendCont = false;

//#define ACCEL_FACTOR          -0.000598  // 2.0 * -9.8 / 32768
//#define GYRO_FACTOR           0.000133  // pi / (131 * 180)
//#define MAG_FACTOR            6e-7

/*int16_t angle[3];
float   rpy[3];
float   quat[4];
int16_t gyroData[3];
int16_t gyroRaw[3];
int16_t accData[3];
int16_t accRaw[3];
int16_t magData[3];
int16_t magRaw[3];

float ax, ay, az;
float gx, gy, gz;
float mx, my, mz;



float aRes;
float gRes;
float mRes;

uint32_t update_hz;
uint32_t update_us;*/
  
//-------- Sonar -------------

#define USNUM             7  
#define USFILTERNUM       5
#define MAXDELAYTIME      49000L

float USRawData[USNUM][USFILTERNUM] = {0};
float USRawDSum                     = 0;
float USFilteredData[USNUM] = {0.0,};

uint16_t USLoopFreq     = 5;    // Hz
uint32_t USStartTime    = 0;
uint32_t USEndTime      = 0;
uint32_t USLoopTime     = 0;
uint32_t _max_time      = 0;

bool b_USSendCont       = false;

int sonarReadCnt        = 0;
uint32_t start_time[7]  = {0};
uint32_t end_time[7]    = {0};
uint32_t duration[7]    = {0};
float distance[7]       = {0};

int sonar_enable[7]   = {LEFTFRONT_EN, RIGHTFRONT_EN, LEFTREAR_EN, RIGHTREAR_EN, REARLEFT_EN, REARCENTER_EN, REARRIGHT_EN};
int sonar_pwm[7]      = {LEFTFRONT_PW, RIGHTFRONT_PW, LEFTREAR_PW, RIGHTREAR_PW, REARLEFT_PW, REARCENTER_PW, REARRIGHT_PW};

//----------- Autonomous charging -----------

uint32_t PWM_CNT       = 0;
bool contact_flag      = false;
 
// ---------- Setup -------------------------

void setup() {

  uint32_t i;
  uint32_t pre_time;

/*
  // Serial 0
  pinMode(PE1, OUTPUT);
  pinMode(PE0, INPUT);

  // Serial 1
  pinMode(PD3, OUTPUT);
  pinMode(PD2, INPUT);
*/  
  Serial.begin(115200);
  delay(500);
  
  Serial1.begin(115200);
  //delay(1000);
  
  Serial.println("Start...");

  attachInterrupt(digitalPinToInterrupt(CNT_PIN), AutoChargingCallback, RISING);  // reads PWM which is generated from NANO(station)
  //cMPU9250 SEN;
  
  bConnected = SEN.begin();
  AccelFactor = SEN.aRes*G;
  GyroFactor = SEN.gRes*Deg2Rad;
  
  for(int i=0; i<3; i++) MagFactor[i] = SEN.mRes*SEN.AK8963_ASA[i];

#if 0  
  if( bConnected == true ) {
    update_hz = 200;
    update_us = 1000000/update_hz;
    filter.begin(update_hz);
    
    for (i=0; i<32; i++) { update(); }
    pre_time = millis();
    while(!SEN.gyro_cali_get_done()) {
      update();
      if (millis()-pre_time > 5000) { break; }
    }
  }
#endif
  
  //imu_.begin();
  //Serial.println("Begin imu...");

  Serial1.println("Connect to pc...");

  b_StartFlag = 0;
  startcnt = 0;
  rsize = 0;
  
  //Serial1.attachInterrupt(Serial_Receive);

  //InitSonar();

  pinMode(PJ1, OUTPUT);
  pinMode(PJ0, OUTPUT);

  pinMode(PH1, OUTPUT);
  pinMode(PH0, OUTPUT);

  //calibrationGyro();

  //Serial.println("imu calibration");

  IMULoopTime = 1000000/IMULoopFreq;
  USLoopTime = 1000000/USLoopFreq;
  
  digitalWrite(PJ0, LOW);
  digitalWrite(PJ1, LOW);

  digitalWrite(PH0, LOW);
  digitalWrite(PH1, LOW);

  setLedToggle(PJ0);
  delay(500);
  setLedToggle(PJ0);
  delay(500);
  setLedToggle(PJ0);
  delay(500);
  setLedToggle(PJ0);
  delay(500);

}

#if 0
uint16_t update( void)
{
  uint16_t ret_time = 0;
  
  static uint32_t tTime;
  
  if( (micros()-tTime) >= update_us )
  {
    ret_time = micros()-tTime;
    tTime = micros();
    
    computeIMU();
    
    gyroData[0] = SEN.gyroADC[0];
    gyroData[1] = SEN.gyroADC[1];
    gyroData[2] = SEN.gyroADC[2];
    
    gyroRaw[0]  = SEN.gyroRAW[0];
    gyroRaw[1]  = SEN.gyroRAW[1];
    gyroRaw[2]  = SEN.gyroRAW[2];
    
    accData[0]  = SEN.accADC[0];
    accData[1]  = SEN.accADC[1];
    accData[2]  = SEN.accADC[2];
    
    accRaw[0]   = SEN.accRAW[0];
    accRaw[1]   = SEN.accRAW[1];
    accRaw[2]   = SEN.accRAW[2];
    
    magData[0]  = SEN.magADC[0];
    magData[1]  = SEN.magADC[1];
    magData[2]  = SEN.magADC[2];
    
    magRaw[0]   = SEN.magRAW[0];
    magRaw[1]   = SEN.magRAW[1];
    magRaw[2]   = SEN.magRAW[2];
  }
  
  return ret_time;
}

void computeIMU( void )
{
  static uint32_t prev_process_time = micros();
  static uint32_t cur_process_time = 0;
  static uint32_t process_time = 0;
  uint32_t i;
  static int32_t gyroADC[3][FILTER_NUM] = {0,};
  int32_t gyroAdcSum;
  
  uint32_t axis;
  
  SEN.acc_get_adc();
  SEN.gyro_get_adc();
  SEN.mag_get_adc();
    
  for (axis = 0; axis < 3; axis++)
  {
    gyroADC[axis][0] = SEN.gyroADC[axis];
    
    gyroAdcSum = 0;
    for (i=0; i<FILTER_NUM; i++)
    {
      gyroAdcSum += gyroADC[axis][i];
    }
    SEN.gyroADC[axis] = gyroAdcSum/FILTER_NUM;
    
    for (i=FILTER_NUM-1; i>0; i--)
    {
      gyroADC[axis][i] = gyroADC[axis][i-1];
    }
    
    if (abs(SEN.gyroADC[axis]) <= 3)
    {
      SEN.gyroADC[axis] = 0;
    }
  }
  
  
  for( i=0; i<3; i++ )
  {
    accRaw[i]   = SEN.accRAW[i];
    accData[i]  = SEN.accADC[i];
    gyroRaw[i]  = SEN.gyroRAW[i];
    gyroData[i] = SEN.gyroADC[i];
    magRaw[i]   = SEN.magRAW[i];
    magData[i]  = SEN.magADC[i];
  }
  
  ax = (float)SEN.accADC[0]*aRes;
  ay = (float)SEN.accADC[1]*aRes;
  az = (float)SEN.accADC[2]*aRes;
  
  gx = (float)SEN.gyroADC[0]*gRes;
  gy = (float)SEN.gyroADC[1]*gRes;
  gz = (float)SEN.gyroADC[2]*gRes;
  
  mx = (float)SEN.magADC[0]*mRes;
  my = (float)SEN.magADC[1]*mRes;
  mz = (float)SEN.magADC[2]*mRes;
  
  
  cur_process_time  = micros();
  process_time      = cur_process_time-prev_process_time;
  prev_process_time = cur_process_time;
  
  if (SEN.calibratingG == 0 && SEN.calibratingA == 0)
  {
    filter.invSampleFreq = (float)process_time/1000000.0f;
    filter.updateIMU(gx, gy, gz, ax, ay, az);
    //filter.update(gx, gy, gz, ax, ay, az, mx, my, mz);
  }
    
  rpy[0] = filter.getRoll();
  rpy[1] = filter.getPitch();
  rpy[2] = filter.getYaw()-180.;
  
  quat[0] = filter.q0;
  quat[1] = filter.q1;
  quat[2] = filter.q2;
  quat[3] = filter.q3;
  
  angle[0] = (int16_t)(rpy[0] * 10.);
  angle[1] = (int16_t)(rpy[1] * 10.);
  angle[2] = (int16_t)(rpy[1] * 1.);

}
#endif

#if 1
void serialEvent1() {
//void Serial_Receive(byte buffer)

  if(!Serial1.available()) return;
    
  byte buffer = Serial1.read();

#ifdef __DEBUG
  Serial.print("Receive data : ");
  Serial.println(buffer);
#endif
  
  if(buffer==0xAA && b_StartFlag==0) {
    startcnt++;
    if(startcnt==1 && b_StartFlag==0) { rsize = 0; }

#ifdef __DEBUG
    Serial.print("start cnt : ");
    Serial.println(startcnt);
#endif
    
    if(startcnt>=3) {
      startcnt = 0;
      b_StartFlag =  1;
      RData[rsize++] = buffer;  

#ifdef __DEBUG
      Serial.print("rsize : ");
      Serial.println(rsize);
#endif
      
      if(rsize>3) {
        rsize = 0;
        RData[0] = 0xAA;
        RData[1] = 0xAA;
        RData[2] = 0xAA;
        rsize = 3;
      }
    } else { RData[rsize++] = buffer; }
  } else { RData[rsize++] = buffer; }
  
  if(b_StartFlag==1 && RData[rsize-1]==0x3B) {
    rsize = 0;
    b_StartFlag = 0;
  
    switch(RData[3]) {
      case SEND_IMUDATA_ONCE:
#ifdef __DEBUG      
        Serial.println("Receive cmd : IMU data once transmmission .");
#endif      
        SEN.update();
        SendIMUData();
        break;

      case SEND_IMUDATA_CONT:
        word_val.cval[0] = RData[4];
        word_val.cval[1] = RData[5];

        IMULoopFreq = word_val.wval;
        IMULoopTime = 1000000/IMULoopFreq;
        
#ifdef __DEBUG      
        Serial.println("Receive cmd : IMU data continous transmission.");
        Serial.print("IMU Loop Freq. : ");
        Serial.println(IMULoopFreq);
        Serial.print("IMU Loop Time : ");
        Serial.println(IMULoopTime);        
#endif      
        
        b_IMUSendCont = true;
        IMUStartTime = micros();
        break;          

      case STOP_IMUDATA_CONT:
        if(b_IMUSendCont == true) b_IMUSendCont = false;
        break;

      case SEND_IMUCALIGYRO:
          b_IMUSendCont = false;
          calibrationGyro();
          b_IMUSendCont = true;
#ifdef __DEBUG      
        Serial.println("Receive cmd : Calibrate Gyro sensor of IMU.");
#endif      
        break;
        
      case SEND_USDATA_ONCE:
#ifdef __DEBUG      
        Serial.println("Receive cmd : UltraSonic Sensor data once transmmission .");
#endif      
        ReadUSSensor();
        SendUSData();
        break;        

      case SEND_USDATA_CONT:
        word_val.cval[0] = RData[4];
        word_val.cval[1] = RData[5];

        USLoopFreq = word_val.wval;
        USLoopTime = 1000000/USLoopFreq;
        
#ifdef __DEBUG      
        Serial.println("Receive cmd : UltraSonar Sensor data continous transmission.");
        Serial.print("US Loop Freq. : ");
        Serial.println(USLoopFreq);
        Serial.print("US Loop Time : ");
        Serial.println(USLoopTime);
#endif      
        
        b_USSendCont = true;
        USStartTime = micros();
        break;       

      case STOP_USDATA_CONT:
        if(b_USSendCont == true) b_USSendCont = false;
        break; 
    } 
  }
   
}

#endif

void InitSonar(void) {
  pinMode(LEFTFRONT_PW, INPUT);
  pinMode(RIGHTFRONT_PW, INPUT);
  pinMode(LEFTREAR_PW, INPUT);
  pinMode(RIGHTREAR_PW, INPUT);
  pinMode(REARLEFT_PW, INPUT);
  pinMode(REARCENTER_PW, INPUT);
  pinMode(REARRIGHT_PW, INPUT);
  
  pinMode(LEFTFRONT_EN, OUTPUT);
  pinMode(RIGHTFRONT_EN, OUTPUT);
  pinMode(LEFTREAR_EN, OUTPUT);
  pinMode(RIGHTREAR_EN, OUTPUT);
  pinMode(REARLEFT_EN, OUTPUT);
  pinMode(REARCENTER_EN, OUTPUT);
  pinMode(REARRIGHT_EN, OUTPUT);

  digitalWrite(LEFTFRONT_EN, LOW);
  digitalWrite(RIGHTFRONT_EN, LOW);
  digitalWrite(LEFTREAR_EN, LOW);
  digitalWrite(RIGHTREAR_EN, LOW);
  digitalWrite(REARLEFT_EN, LOW);
  digitalWrite(REARCENTER_EN, LOW);
  digitalWrite(REARRIGHT_EN, LOW);
  
}

int ReadSonar(int snum)
{
  uint32_t st, et;
  
    digitalWrite(sonar_enable[snum], HIGH);  
    
    delay(1);

#ifdef ___DEBUG
    st = micros();
#endif
    
    _max_time = micros() + MAXDELAYTIME;
    while(!digitalRead(sonar_pwm[snum])) {
      if(micros() > _max_time) {    // start timeout : _max_time
        duration[snum] = 0;
        return -1;
      }
    }

#ifdef ___DEBUG
    et = micros();

    Serial.print("start run time diff(");
    Serial.print(snum+1);
    Serial.print("): ");
    Serial.println(et - st);
    
    Serial.print("start max time : "); Serial.println(_max_time);
#endif    
    
    start_time[snum] = micros();

    _max_time = micros() + MAXDELAYTIME;


#ifdef ___DEBUG
    st = micros();
#endif
    
    while(digitalRead(sonar_pwm[snum])) {
      if(micros() > _max_time) {    // end timeout : _max_time
        duration[snum] = 0;
        return -2;
      }
    }
    end_time[snum] = micros();

#ifdef ___DEBUG
    et = micros();

    Serial.print("end run time diff(");
    Serial.print(snum+1);
    Serial.print("): ");
    Serial.println(et - st);
#endif    

    duration[snum] = end_time[snum] - start_time[snum];

#ifdef ___DEBUG
    Serial.print("duration : "); Serial.println(duration[snum]);
#endif    

    USFilter1(snum);
    distance[snum] = duration[snum]*2.54/147.0;
    digitalWrite(sonar_enable[snum], LOW);  
    return 1;

#if 0
  if(sonarReadCnt == 1) {
    digitalWrite(LEFTFRONT_EN, LOW);  
    digitalWrite(RIGHTREAR_EN, LOW);  
    digitalWrite(REARLEFT_EN, LOW);

    //delay(2);

    while(!digitalRead(LEFTFRONT_PW)) ;
    start_time[LF] = micros();

    while(!digitalRead(RIGHTREAR_PW)) ;
    start_time[RR] = micros();

    while(!digitalRead(REARLEFT_PW)) ;
    start_time[R_L] = micros();

    //----------------------------------

    while(digitalRead(LEFTFRONT_PW)) ;
    end_time[LF] = micros();

    while(digitalRead(RIGHTREAR_PW)) ;
    end_time[RR] = micros();

    while(digitalRead(REARLEFT_PW)) ;
    end_time[R_L] = micros();

    duration[LF] = end_time[LF] - start_time[LF];
    duration[LF] = end_time[LF] - start_time[LF];
  }
#endif
    
}

void USFilter1(int snum) {
  int i;
  
  USRawData[snum][0] = duration[snum];
  USRawDSum = 0;

  for(i=0; i<USFILTERNUM; i++) USRawDSum += USRawData[snum][i];
  
  USFilteredData[snum] = USRawDSum/USFILTERNUM;

  for(i=USFILTERNUM-1; i>0; i--) USRawData[snum][i] = USRawData[snum][i-1];

  distance[snum] = USFilteredData[snum]*2.54/147.0;

}


void SendIMUData(void) {
  for(int i=0; i<WData_len; i++) WData[i] = 0;
  
  WData[0] = 0xAA;
  WData[1] = 0xAA;
  WData[2] = 0xAA;  
  WData[3] = SEND_IMUDATA;
  float_val.fval = SEN.gyroADC[0] * GyroFactor;
  WData[4] = float_val.cval[0];
  WData[5] = float_val.cval[1];
  WData[6] = float_val.cval[2];
  WData[7] = float_val.cval[3];   
  float_val.fval = SEN.gyroADC[1] * GyroFactor;
  WData[8] = float_val.cval[0];
  WData[9] = float_val.cval[1];
  WData[10] = float_val.cval[2];
  WData[11] = float_val.cval[3];   
  float_val.fval = SEN.gyroADC[2] * GyroFactor;
  WData[12] = float_val.cval[0];
  WData[13] = float_val.cval[1];
  WData[14] = float_val.cval[2];
  WData[15] = float_val.cval[3];   
  float_val.fval = SEN.accADC[0] * AccelFactor;
  WData[16] = float_val.cval[0];
  WData[17] = float_val.cval[1];
  WData[18] = float_val.cval[2];
  WData[19] = float_val.cval[3];   
  float_val.fval = SEN.accADC[1] * AccelFactor;
  WData[20] = float_val.cval[0];
  WData[21] = float_val.cval[1];
  WData[22] = float_val.cval[2];
  WData[23] = float_val.cval[3];
  float_val.fval = SEN.accADC[2] * AccelFactor;
  WData[24] = float_val.cval[0];
  WData[25] = float_val.cval[1];
  WData[26] = float_val.cval[2];
  WData[27] = float_val.cval[3];   
  float_val.fval = SEN.magADC[0] * MagFactor[0];
  WData[28] = float_val.cval[0];
  WData[29] = float_val.cval[1];
  WData[30] = float_val.cval[2];
  WData[31] = float_val.cval[3];
  float_val.fval = SEN.magADC[1] * MagFactor[1];
  WData[32] = float_val.cval[0];
  WData[33] = float_val.cval[1];
  WData[34] = float_val.cval[2];
  WData[35] = float_val.cval[3];
  float_val.fval = SEN.magADC[2] * MagFactor[2];
  WData[36] = float_val.cval[0];
  WData[37] = float_val.cval[1];
  WData[38] = float_val.cval[2];
  WData[39] = float_val.cval[3];  
  float_val.fval = SEN.quat[0];
  WData[40] = float_val.cval[0];
  WData[41] = float_val.cval[1];
  WData[42] = float_val.cval[2];
  WData[43] = float_val.cval[3];
  float_val.fval = SEN.quat[1];
  WData[44] = float_val.cval[0];
  WData[45] = float_val.cval[1];
  WData[46] = float_val.cval[2];
  WData[47] = float_val.cval[3];
  float_val.fval = SEN.quat[2];
  WData[48] = float_val.cval[0];
  WData[49] = float_val.cval[1];
  WData[50] = float_val.cval[2];
  WData[51] = float_val.cval[3];
  float_val.fval = SEN.quat[3];
  WData[52] = float_val.cval[0];
  WData[53] = float_val.cval[1];
  WData[54] = float_val.cval[2];
  WData[55] = float_val.cval[3];
  float_val.fval = SEN.temperature;
  WData[56] = float_val.cval[0];
  WData[57] = float_val.cval[1];
  WData[58] = float_val.cval[2];
  WData[59] = float_val.cval[3];
  WData[60] = 0x3B;
  
  for(int i=0; i<61; i++) Serial1.write(WData[i]);  // set size includes contact flag data
}

void SendUSData(void)
{
  for(int i=0; i<WData_len; i++) WData[i] = 0;
  
  WData[0] = 0xAA;
  WData[1] = 0xAA;
  WData[2] = 0xAA;  
  WData[3] = SEND_USDATA;
  
  float_val.fval = distance[0];
  WData[4] = float_val.cval[0];
  WData[5] = float_val.cval[1];
  WData[6] = float_val.cval[2];
  WData[7] = float_val.cval[3];   

  float_val.fval = distance[1];
  WData[8] = float_val.cval[0];
  WData[9] = float_val.cval[1];
  WData[10] = float_val.cval[2];
  WData[11] = float_val.cval[3];   

  float_val.fval = distance[2];
  WData[12] = float_val.cval[0];
  WData[13] = float_val.cval[1];
  WData[14] = float_val.cval[2];
  WData[15] = float_val.cval[3];   

  float_val.fval = distance[3];
  WData[16] = float_val.cval[0];
  WData[17] = float_val.cval[1];
  WData[18] = float_val.cval[2];
  WData[19] = float_val.cval[3];   

  float_val.fval = distance[4];
  WData[20] = float_val.cval[0];
  WData[21] = float_val.cval[1];
  WData[22] = float_val.cval[2];
  WData[23] = float_val.cval[3];   

  float_val.fval = distance[5];
  WData[24] = float_val.cval[0];
  WData[25] = float_val.cval[1];
  WData[26] = float_val.cval[2];
  WData[27] = float_val.cval[3];   

  float_val.fval = distance[6];
  WData[28] = float_val.cval[0];
  WData[29] = float_val.cval[1];
  WData[30] = float_val.cval[2];
  WData[31] = float_val.cval[3];   

  WData[32] = 0x3B;

   for(int i=0; i<33; i++)
    Serial1.write(WData[i]); 
}

void printRawData()
{
  // Print acceleration values in milligs!
  /*Serial.print("ax = "); Serial.print(SEN.ax, 2);
  Serial.print(" ay = "); Serial.print(SEN.ay, 2);
  Serial.print(" az = "); Serial.print(SEN.az, 2); Serial.println(" mg");
  // Print gyro values in degree/sec
  Serial.print("gx = "); Serial.print(SEN.gx, 2);
  Serial.print(" gy = "); Serial.print(SEN.gy, 2);
  Serial.print(" gz = "); Serial.print(SEN.gz, 2); Serial.println(" deg/s");
  // Print mag values in degree/sec
  Serial.print("mx = "); Serial.print(SEN.mx, 2);
  Serial.print(" my = "); Serial.print(SEN.my, 2);
  Serial.print(" mz = "); Serial.print(SEN.mz, 2); Serial.println(" mG");
  */
  Serial.print("q0 = "); Serial.print(SEN.quat[0], 6);
  Serial.print(" qx = "); Serial.print(SEN.quat[1], 6);
  Serial.print(" qy = "); Serial.print(SEN.quat[2], 6);
  Serial.print(" qz = "); Serial.println(SEN.quat[3], 6);

  /*Serial.print("angle0 = "); Serial.print(SEN.angle[0]);
  Serial.print(" angle1 = "); Serial.print(SEN.angle[1]);
  Serial.print(" angle2 = "); Serial.println(SEN.angle[2]);*/

  /*Serial.print("ax = "); Serial.print(SEN.accADC[0] * ACCEL_FACTOR, 2);
  Serial.print(" ay = "); Serial.print(SEN.accADC[1] * ACCEL_FACTOR, 2);
  Serial.print(" az = "); Serial.print(SEN.accADC[2] * ACCEL_FACTOR, 2); Serial.println(" mg");
  // Print gyro values in degree/sec
  Serial.print("gx = "); Serial.print(SEN.gyroADC[0] * GYRO_FACTOR, 2);
  Serial.print(" gy = "); Serial.print(SEN.gyroADC[1] * GYRO_FACTOR, 2);
  Serial.print(" gz = "); Serial.print(SEN.gyroADC[2] * GYRO_FACTOR, 2); Serial.println(" deg/s");
  // Print mag values in degree/sec
  Serial.print("mx = "); Serial.print(SEN.magADC[0] * MAG_FACTOR, 2);
  Serial.print(" my = "); Serial.print(SEN.magADC[1] * MAG_FACTOR, 2);
  Serial.print(" mz = "); Serial.print(SEN.magADC[2] * MAG_FACTOR, 2); Serial.println(" mG");
  
  Serial.print("q0 = "); Serial.print(SEN.quat[0], 2);
  Serial.print(" qx = "); Serial.print(SEN.quat[1], 2);
  Serial.print(" qy = "); Serial.print(SEN.quat[2], 2);
  Serial.print(" qz = "); Serial.println(SEN.quat[3], 2);*/
  
}

void printOrient(void)
{
  double theta;
  //Serial.print("q0 = "); Serial.print(SEN.quat[0], 2);
  //Serial.print(" qx = "); Serial.print(SEN.quat[1], 2);
  //Serial.print(" qy = "); Serial.print(SEN.quat[2], 2);
  //Serial.print(" qz = "); Serial.println(SEN.quat[3], 2);
  
  theta = atan2f(SEN.quat[1] * SEN.quat[2] + SEN.quat[0] * SEN.quat[3],
    0.5f - SEN.quat[2] * SEN.quat[2] - SEN.quat[3] * SEN.quat[3]);

  Serial.print(" theta = "); Serial.println(theta, 8);
}
    
void setLedToggle(uint8_t pin)
{
  digitalWrite(pin, !digitalRead(pin)); 
}


void calibrationGyro()
{
  uint32_t pre_time;
  uint32_t t_time;

  const uint8_t led_ros_connect = 3;

  SEN.gyro_cali_start();
  
  t_time   = millis();
  pre_time = millis();

  while(!SEN.gyro_cali_get_done())
  {
    SEN.update();

    if (millis()-pre_time > 5000)
    {
      break;
    }
    if (millis()-t_time > 100)
    {
      t_time = millis();
      setLedToggle(led_ros_connect);
    }
  }
}

void ReadUSSensor()
{
  int res;
  
  res = ReadSonar(LF);
  if(res<0) {
    distance[LF] = res;
  }
    
  res = ReadSonar(RR);
  if(res<0)
    distance[RR] = res;
    
  res = ReadSonar(R_R);
  if(res<0)
    distance[R_R] = res;

#ifdef _DEBUG
  //if(distance[LF] >= 0)
    Serial.print(distance[LF]);
  //else
  //  Serial.print(distance[LF]);
  
  Serial.print(",");

  //if(distance[RR] >= 0)
    Serial.print(distance[RR]);    
  Serial.print(",");

  //if(distance[R_R] >= 0)
    Serial.println(distance[R_R]);
  Serial.print(",");
#endif

  res = ReadSonar(LR);
  if(res<0)
    distance[LR] = res;
    
  res = ReadSonar(RF);
  if(res<0)
    distance[RF] = res;
    
  res = ReadSonar(R_L);
  if(res<0)
    distance[R_L] = res;

#ifdef _DEBUG  
  //if(distance[LR] >= 0)
    Serial.print(distance[LR]);     
  Serial.print(",");

  //if(distance[RF] >= 0)
    Serial.print(distance[RF]);
  Serial.print(",");

  //if(distance[R_L] >= 0)
    Serial.println(distance[R_L]);
  Serial.print(",");
#endif

  res = ReadSonar(R_C);
  if(res<0)
    distance[R_C] = res;

#ifdef _DEBUG  
  //if(distance[R_C] >= 0)
    Serial.println(distance[R_C]); 
#endif
  
}

void loop() {
  digitalWrite(PJ1, HIGH);

#if 0
  ReadSonar(LF);
  Serial.print("LF:");
  Serial.println(distance[Lf]);

  ReadSonar(LR);
  Serial.print("LR:");
  Serial.println(distance[LR]);

  ReadSonar(RF);
  Serial.print("RF:");
  Serial.println(distance[RF]);

  ReadSonar(RR);
  Serial.print("RR:");
  Serial.println(distance[RR]);

  ReadSonar(R_L);
  Serial.print("R_L:");
  Serial.println(distance[R_L]);

  ReadSonar(R_C);
  Serial.print("R_C:");
  Serial.println(distance[R_C]);

  ReadSonar(R_R);
  Serial.print("R_R:");
  Serial.println(distance[R_R]);
#endif

#if 0  
  ReadSonar(LF);
  ReadSonar(RR);
  ReadSonar(R_R);
  
  Serial.print("LF:");
  Serial.print(distance[LF]);
  Serial.print(" ");
  Serial.print("RR:");
  Serial.print(distance[RR]);
  Serial.print(" ");
  Serial.print("R_R:");
  Serial.println(distance[R_R]);
  Serial.print(" ");

  ReadSonar(LR);
  ReadSonar(RF);
  ReadSonar(R_L);
  Serial.print("LR:");
  Serial.print(distance[LR]); 
  Serial.print(" ");
  Serial.print("RF:");
  Serial.print(distance[RF]);
  Serial.print("R_L:");
  Serial.println(distance[R_L]);
  Serial.print(" ");

  ReadSonar(R_C);
  Serial.print("R_C:");
  Serial.println(distance[R_C]); 
#endif

  if(b_IMUSendCont == true) {
    IMUEndTime = micros();
    if((IMUEndTime - IMUStartTime) > IMULoopTime) {
      digitalWrite(PJ1, HIGH);
      
      SEN.update();

      SendIMUData();

      //printRawData();
      //printOrient();

      digitalWrite(PJ1, LOW);

      IMUStartTime = micros();
    }  
  }

#if 0
  if(b_USSendCont == true) {
    USEndTime = micros();
    if((USEndTime - USStartTime) > USLoopTime) {
      digitalWrite(PH1, HIGH);

        ReadUSSensor();

        SendUSData();
        
      digitalWrite(PH1, LOW);

      USStartTime = micros();
    }
  }
#endif

  
#if 0  
  digitalWrite(PJ1, LOW);

  SEN.update();

  //printRawData();
  printOrient();

  Serial1.println("Send data...");
#endif
  
  delay(1);
  //delay(500);

}

void AutoChargingCallback() {
  if(!contact_flag) PWM_CNT++;
  if(PWM_CNT > PWM_threshold) contact_flag = true;
}
